/*
 * nLoader
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2, as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.
 */

#include "types.h"
#include "patchboot2.h"
#include "utils.h"
#include "casos.h"

#define IGNORE 0
#define NOP 0xE1A00000
#define PATCH_SETW(A,B) *(uint32_t *)(A) = (B)
#define PATCH_SETB(A,B) *(uint8_t *)(A) = (B)

#define IB2_ID		0
#define IB2_ASIC	1
#define IB2_MANUF	2
#define IB2_B2VER	3

#define NBOOT2 sizeof(boot2_patches)/sizeof(boot2_patches[0])
static const uint32_t boot2_patches[][IB2_B2VER+1] = {
//	CX			offsets
//	Boot2 ID			ASIC				Manuf modelID		Boot2Version
	{CXB440_8,			ASIC_CXB440_8,		MANUF_CXB440_8,		IGNORE},
	{CXB450_14,			ASIC_CXB450_14,		MANUF_CXB450_14,		IGNORE},
};

uint8_t getBoot2Index(uint32_t id) {
	uint8_t i=0;
	for(i=0;i<NBOOT2;i++) {
		if(boot2_patches[i][IB2_ID]==id)
			break;
	}
	return i;
}

//! Patch the Boot2.

int patch_Boot2() {
	uint32_t id = *((uint32_t*)(0x11800020));
	uint8_t index = getBoot2Index(id);
	unsigned char asicflags = ((*(volatile unsigned int*) 0x900A002C)>>26)&0b11111;

	if(index<NBOOT2){
		PATCH_SETW(0xA4012EB4,0xFFFFFFFF);
		if(boot2_patches[index][IB2_B2VER]) {
			PATCH_SETW(boot2_patches[index][IB2_B2VER],0);
		}

#ifndef CAS_OS
		if(asicflags != 0) {
			uint32_t fakeasic1=0; // CX
			uint32_t fakeasic2=0xE3A04000; // CX
			#define modelid 0x10
#else
		if(asicflags != 1) {
			uint32_t fakeasic1= 0x00010105; // CX CAS
			uint32_t fakeasic2= 0xE3A04341; // CX CAS
			#define modelid 0x0F
#endif
			if(boot2_patches[index][IB2_MANUF]) {
				PATCH_SETW(boot2_patches[index][IB2_MANUF],0xE3A00000|modelid);
			}
			if(boot2_patches[index][IB2_ASIC]) {
				PATCH_SETB(boot2_patches[index][IB2_ASIC],0x54);
				PATCH_SETW(boot2_patches[index][IB2_ASIC]+0x17,fakeasic2);
				PATCH_SETW(boot2_patches[index][IB2_ASIC]+0x1B,NOP);
				PATCH_SETW(boot2_patches[index][IB2_ASIC]+0x48B,fakeasic1);
			}
		}
                // downgrade fix, it's the very first occurrence of aa c6 8c 92 xref
                /*
                 RAM:118BE690 loc_118BE690                            ; CODE XREF: sub_118BE600+6C↑j
                 RAM:118BE690                                         ; sub_118BE600+B4↓j ...
                 RAM:118BE690                 LDR             R0, [R4]
                 RAM:118BE694                 LDR             LR, =0x928CC6AA
                 RAM:118BE698                 CMP             R0, LR
                 RAM:118BE69C                 BNE             loc_118BE644
                 */
                if(id == CXB440_8) PATCH_SETW(0x118BE690,0xE3A00000); // will never be true
                else if(id == CXB450_14) PATCH_SETW(0x118BE628,0xE3A00000); // will never be true
		return 1;
	} else {
		return 0;
	}
}
