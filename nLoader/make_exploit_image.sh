#!/bin/bash

set -euo pipefail

if [ $# != 4 ]; then
	echo "Usage: $0 loader.bin boot1.5_4.4.0.8.img boot2.img output.img"
	exit 1
fi

image_version="1.1 " # must be exactly 4 characters, pad with spaces
echo "Image version (must be exactly 4 characters, pad with spaces): '$image_version'"
nop_sled_size=0x1f04 # This is for boot1.5 4.4.0.8. See README.txt for explanation and how to get this value for boot1.5 versions other than 4.4.0.8
loader_area_size=0x40000 # This is unnecessarily big, but nMaker relies on it! DO NOT change, to keep nMaker compatibility
boot1p5_location_in_memory=0x11200000 # Boot1.5 is loaded at address 0x11200000 (regardless of version, AFAIK)

loader_bin="$1"
echo "Input loader image: $loader_bin"
loader_bin_size=`wc -c < "$loader_bin" | tr -dc 1234567890`
echo "Loader size in bytes: $loader_bin_size"
# The top 8 bytes are used for the boot2 base address and size. The size is now unused but if it is removed, nMaker will break
loader_bin_max_size=$(($loader_area_size-8))
if [ $loader_bin_size -gt $loader_bin_max_size ]; then
	echo "ERROR: Loader is too big, maximum size is $loader_bin_max_size bytes"
	exit 1
fi

boot1p5_image="$2" # must be version 4.4.0.8, compressed, without boot2 appended
echo "Input boot1.5 image: $boot1p5_image"
boot2_image="$3" # must be the compressed one, without boot1.5 prepended
echo "Input boot2 image: $boot2_image"
boot2_image_size=`wc -c < "$boot2_image" | tr -dc 1234567890`
echo "Boot2 size in bytes: $boot2_image_size"
boot2_image_size_rounded=$(((($boot2_image_size+3)/4)*4))
echo "Boot2 size rounded to nearest 4 bytes: $boot2_image_size_rounded"
output_image="$4"
echo "Output image: $output_image"

# Create scratch file of correct size
rm -f tmp.bin
dd if=/dev/zero of=tmp.bin bs=$(($boot2_image_size_rounded+$loader_area_size+$nop_sled_size+8)) count=1 2>/dev/null

# Copy embedded boot2 to the beginning of the image, before the loader
dd if="$boot2_image" of=tmp.bin bs=$boot2_image_size count=1 conv=notrunc seek=0 2>/dev/null

# Copy loader immediately after boot2
# Using the rounded size makes sure the loader (which comes after the boot2) is 32-bit aligned so it can be executed
dd if="$loader_bin" of=tmp.bin bs=1 conv=notrunc seek=$boot2_image_size_rounded 2>/dev/null

# Add nop sled after loader; this will overwrite the beginning of the running boot2
python3 -c "import sys;sys.stdout.buffer.write(b\"\x00\x00\xa0\xe1\"*($nop_sled_size//4))" | dd of=tmp.bin seek=$(($boot2_image_size_rounded+$loader_area_size)) bs=1 conv=notrunc 2>/dev/null

# Add trampoline after the nop sled, to jump to the loader; the loader and embedded boot2 will already have been copied into RAM before this code is reached
# It can't be longer than ~8 bytes or it will crash - perhaps because the copy will not have finished before the code doing the copying gets overwritten
# ldr pc, [pc, #-4] <- When using PC as the base register it contains an address 8 bytes after the address of the actual current instruction, so this is really +4
# db 111c0000 <- Payload address 0x111c0000 (gives us 256k for payload, minus 8 bytes)
printf "\x04\xF0\x1F\xE5\x00\x00\x1C\x11" | dd of=tmp.bin bs=1 count=8 seek=$(($boot2_image_size_rounded+$loader_area_size+$nop_sled_size)) conv=notrunc 2>/dev/null

# Write embedded boot2 location at 0x111FFFF8 (DO NOT change, to keep nMaker compatibility)
embedded_boot2_location_in_memory=`printf "%08X" $((boot1p5_location_in_memory-$loader_area_size-$boot2_image_size_rounded))`
echo "Embedded boot2 image will end up at address: 0x$embedded_boot2_location_in_memory"
embedded_boot2_location_little_endian=`echo $embedded_boot2_location_in_memory | awk '{for (i=7;i>=1;i=i-2) printf "%s",substr($1,i,2)}'`
echo $embedded_boot2_location_little_endian | xxd -r -p | dd of=tmp.bin bs=1 count=4 seek=$(($boot2_image_size_rounded+$loader_area_size-8)) conv=notrunc 2>/dev/null

# Create outer image header so boot1.5 will load the exploit image, and prepend boot1.5 to it so it can be booted directly in an emulator
# For more info on this format, see https://hackspire.org/index.php?title=OS_upgrade_files#boot2.img
# Name: 'nLoader ' (8 bytes)
# Version: '1.1 ' (4 bytes)
# Compatible: 0F (CX CAS) and 10 (CX) - I'm not sure why, but all of TI's images have an extra 5 before the product IDs; also, they are in ASCII, even though they're hex values.
# Load address: $embedded_boot2_location_in_memory (since the boot2 is the first thing in the image). 
# Not specifying flags in field 8080 and leaving it as only 4 bytes means the image is uncompressed. The exploit will only work if the image is uncompressed - see README.txt.

raw_image_size=$(wc -c < tmp.bin | tr -dc 1234567890)
echo "Raw image size in bytes: $raw_image_size"
# +42 for the size of this added outer header
(cat "$boot1p5_image"; printf '800F%08X' $(($raw_image_size+42)) | xxd -r -p; printf '\x80\x00\x80\x48nLoader \x80\x24'"$image_version"'\x80\x1350F\x80\x13510\x80\x84'; echo "$embedded_boot2_location_in_memory" | xxd -r -p; printf '807F%08X' $raw_image_size | xxd -r -p; cat tmp.bin; printf '\x02\xF0\xFF\xF0') > "$output_image"
rm -f tmp.bin

output_image_size=$(wc -c < "$output_image" | tr -dc 1234567890)
echo "Output image size in bytes: $output_image_size"

echo "Done, $output_image created"

exit 0
