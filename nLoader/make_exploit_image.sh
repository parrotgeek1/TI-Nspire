#!/bin/bash -e
echo Making exploit image
img="$2"
echo "Output image: $img"
nopsize=0x1f04
ldrsz=0x40000 # this is unnecessarily big, but nMaker relies on it
# Payload address 0x111c0000 (gives us 256k for payload...minus 8 bytes)
# boot2 is copied to the beginning
b2="$3" # the compressed one
echo "Input Boot2 image: $b2"
boot1p5="$4" # must be 4.4.0.8
echo "Input Boot1.5 image: $boot1p5"
b2sz=$((((`wc -c < "$b2"|tr -dc 1234567890`+3)/4)*4))
echo "Boot2 size rounded to nearest 4 bytes: $b2sz"
rm -f tmp.bin
dd if=/dev/zero of=tmp.bin bs=$(($b2sz+$ldrsz+$nopsize+8)) count=1 2>/dev/null
# nop sled
python3 -c "import sys;sys.stdout.buffer.write(b\"\x00\x00\xa0\xe1\"*($nopsize//4))" | dd of=tmp.bin seek=$(($b2sz+$ldrsz)) bs=1 conv=notrunc 2>/dev/null
# copy trampoline at 11201f04
# LDR PC, [PC,#-4]
# db 111c0000
# this code can't be longer than ~8 bytes or crash
base=`printf "%08X" $((0x11200000-$ldrsz-$b2sz))`
echo "Inner compressed boot2 base address: 0x$base"
printf "\x04\xF0\x1F\xE5\x00\x00\x1C\x11" | dd of=tmp.bin bs=1 count=8 seek=$(($b2sz+$ldrsz+$nopsize)) conv=notrunc 2>/dev/null
# write boot2 base at 111FFFF8 (DO NOT change, to keep nMaker compatibility)
baseflip=`echo $base | awk '{for (i=7;i>=1;i=i-2) printf "%s",substr($1,i,2)}'`
echo $baseflip | xxd -r -p| dd of=tmp.bin bs=1 count=4 seek=$(($b2sz+$ldrsz-8)) conv=notrunc 2>/dev/null
dd if="$1" of=tmp.bin bs=1 conv=notrunc seek=$b2sz 2>/dev/null
# add boot2
szb2=`wc -c < "$b2"|tr -dc 1234567890`
dd if="$b2" of=tmp.bin bs=$szb2 count=1 conv=notrunc seek=0 2>/dev/null
szld=`wc -c < "$1"|tr -dc 1234567890`
echo "Loader size: $szld bytes"
if [ $szld -gt $(($ldrsz-8)) ]; then
	echo "Loader is too big, maximum size is $(($ldrsz-8)) bytes"
	exit 1
fi
tmpBinSize=$(wc -c < tmp.bin|tr -dc 1234567890)
# if you really need to know, look at https://hackspire.org/index.php?title=OS_upgrade_files#boot2.img
# +32 for the size of this added outer header
(cat "$boot1p5"; printf '800F%08X' $(($tmpBinSize+32)) | xxd -r -p; printf '\x80\x00\x80\x44nLdr\x80\x1350F\x80\x13510\x80\x84'; echo "$base" | xxd -r -p; printf '807F%08X' $tmpBinSize | xxd -r -p; cat "tmp.bin"; printf '\x02\xF0\xFF\xF0') > "$img"
OutSize=$(wc -c < "$img"|tr -dc 1234567890)
echo Done, "$img" created "($OutSize bytes)"
rm -f tmp.bin
exit 0
